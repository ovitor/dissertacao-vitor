\chapter{Aspectos de implementação} \label{cap:aspectos-de-implementacao}

Neste capítulo será abordado os aspectos de implementação. Dificuldades e as
soluções encontradas para construir o \software, que é um dos componentes
da arquitetura apresentada no capítulo \vref{cap:quatro}.

%\section{TV-Health} \label{sec:tv-health} 

A partir do considerado no capítulo \ref{cap:fundamentacao-teorica}, surge o
protótipo TV-Health, com o intuito de resolver alguns dos problemas da
assistência domiciliar à saúde.

\section{\textit{Hardware} utilizado}

O \stb[] escolhido possui especificações técnicas robustas, listadas na 
tabela \ref{tab:stb-specs}. Este STB foi resultado de um projeto de pesquisa
fomentado pela Agência Nacional de Energia Elétrica (ANEEL) e executado pela
empresa CRAFF. Foi reutilizado neste trabalho por se tratar de 
uma pesquisa em que o autor participou efetivamente.

\tabela{stb-specs}{Especificação STB}{0.9}

O STB representado na figura \vref{fig:stb-real} foi montado na empresa
CRAFF, na figura pode ser verificado as entradas USB, o leitor de cartões
microSD (na parte da frente) e as entradas de vídeo (HDMI e RCA) além da 
conexão com a antena externa e a conexão com a fonte de energia na
parte de trás).

\section{\textit{Software} utilizado}

Por se tratar de um sistema embarcado robusto, faz-se necessário a instalação
de programas capazes de gerenciar o \hardware[] disponível. Para tanto, o
sistema operacional escolhido foi o GNU/Linux distribuição Linaro (derivado da
distribuição Ubuntu) \textit{kernel} 3.4 portável para a arquitetura 
ARM com \textit{drivers} específicos para a plataforma desenvolvida.

\figurasimples{stb}{Camadas do sistema embarcado}{4cm}

Na camada de usuário utilizamos o \software[] \xbmc[] - um gerenciador de mídia
- como plataforma de exibição gráfica. É através dele que o usuário irá 
interagir com as aplicações desenvolvidas. Foram necessárias algumas 
modificações por conta dos objetivos específicos definidos para esta pesquisa,
e do contexto do trabalho desenvolvido. Na figura \ref{fig:tela-principal}
(Apêndice \fullref{apendice:tv-health})
destaque para a tela inicial do \software[] \xbmc[] e para o menu ``Sua Saúde''.
Os outros menus representam funcionalidades padrão do \software[] em questão,
tais como acesso a mídias (imagens, vídeos e áudios) e acesso a TV Digital aberta.

Ao clicar no menu ``Sua Saúde'', acessamos a tela com os módulos desenvolvidos
para este trabalho (figura \ref{fig:tela-principal-sua-saude} - Apêndice 
\fullref{apendice:tv-health}).

\section{Aplicações interativas} \label{subsec:aplicacoes-tv-health}

O intuito das aplicações é melhorar a comunicação entre o doente e cuidador com
a equipe médica e seus parentes, além de permitir que o usuário utilize o
controle remoto como um ``botão de pânico''. Por fim, um dos módulos da
aplicação permite ao usuário escolher, dentre os sintomas, aqueles que mais
caracterizam a sua situação e obter uma resposta do sistema relacionada às
escolhas. As aplicações  propostas foram validadas através da conclusão do
projeto \nextsaude[] e da aprovação de artigos acadêmicos apresentados em
Congressos.

Nossa solução foi projetada para atender aos requisitos que uma plataforma
embarcada - com as características da tabela \ref{tab:stb-specs} - demanda. Apesar 
das especificações do \hardware[], o desenvolvimento foi encaminhado para 
obtermos um \software[] simples em consumo de recursos.

As soluções foram implementadas utilizando, quando necessário, o paradigma
de programação Orientada a Objetos. O desenvolvimento procedural foi aplicado
com o intuito de realizar pequenas tarefas no sistema, tais como agendamento
de execução de tarefas, atualização das aplicações, desligamento automático etc.

Além disso, também fizemos uso de \webservices[] através da Internet, acessando
outros sistemas e complementando as funcionalidades desejadas. As linguagens
escolhidas para compor o sistema foram as linguagens \python[] e \shell.

\subsection{Módulo \textit{web}}

Foi necessária a implantação de um módulo \textit{web} para gerenciar as 
informações básicas do usuário. Neste sistema será possível cadastrar um 
paciente, seus alertas e contatos de emergência. O sistema foi desenvolvido
na linguagem \python[] e funciona no STB. Ele pode ser acessado através de
um navegador conectado a rede Wi-Fi local. A tabela \ref{tab:web-api} apresenta
a API disponível no sistema. A figura \vref{fig:web-db} representa o diagrama
de entidades e relação da aplicação.

\tabela{web-api}{Lista de métodos disponíveis por API}{0.9}

\subsection{Módulo \textit{service.notification}}\label{subsubsec:notification}

Este módulo é responsável por apresentar na tela da televisão as notificações e
alertas recebidos no STB. Existem dois tipos de exibição de mensagens, a
primeira delas, denominada ``caixa de diálogo'' (figura
\vref{fig:notification-1} - Apêndice \ref{apendice:tv-health}), 
aparece no meio da tela, ocupando boa parte da mesma.
Esse tipo de notificação é utilizada quando é necessário tirar a atenção do
usuário da programação televisiva e passar a atenção para a mensagem exibida.
Mensagens importantes e de cunho emergencial podem utilizar esse tipo de
notificação. O diagrama de atividades representado na figura
\ref{fig:notification-sd-dialogbox} foi utilizado como base para o
desenvolvimento desta aplicação.

\figurasimples{notification-sd-dialogbox}{Diagrama de Sequência para
módulo \textit{service.notification}. Alerta do tipo caixa de
diálogo.}{10cm}

\figurasimples{notification-sd-popup}{Diagrama de Sequência para
módulo \textit{service.notification}. Alerta do tipo 
\textit{pop-up}.}{10cm}

O segundo tipo de notificação é denominada de \textit{pop-up}. Com esse modelo,
a mensagem é exibida no canto superior direito da tela, fazendo com que a
atenção do usuário não seja totalmente requerida. Mensagens de cunho informativo
podem utilizar esse tipo de notificação. A figura \ref{fig:notification-2} 
(Apêndice \ref{apendice:tv-health}) mostra esta outra possibilidade em ação.
O diagrama de sequência ilustrado na figura \ref{fig:notification-sd-popup}
difere da anterior, pois nesta, não é necessário, por parte do usuário, nenhuma
ação, uma vez que a mensagem desaparece após alguns segundos de exibição.

O módulo \textit{service.notification} foi desenvolvido utilizando a linguagem
\python[] e sua lógica faz com que constantemente execute um \textit{pooling} 
à aplicação em nuvem buscando por mensagens destinadas à esta instância de 
\software. Caso a pergunta tenha uma resposta negativa, o programa espera um 
tempo e refaz a requisição. Caso a resposta seja positiva, ou seja, exista 
alguma mensagem para aquele usuário, o programa faz o \download[] e agenda a
exibição. 

A resposta da requisição carrega informações pertinentes, um exemplo no formato
JSON é apresentado a seguir:

\begin{listing}[ht!]
\inputminted{json}{codigos/message.json}
\caption{Conteúdo da requisição de uma mensagem}
\label{lst:notification-json}
\end{listing}

O \software[] no STB verifica o conteúdo JSON, atentando-se para os campos 
\texttt{startDateTime} e \texttt{expirationDateTime} que representam quando 
iniciar a exibição da mensagem e quando não exibir mais a mensagem 
respectivamente, o tipo de notificação - se será do tipo \textit{pop-up} ou
caixa de diálogo -, a criticidade da mensagem - indicando se ela deve ser
exibida interrompendo a programação ou não e o conteúdo da mensagem. 

Após a correta leitura do conteúdo JSON, a mensagem é preparada para ser 
exibida. O código \ref{lst:notification-popup} faz uso da API do aplicativo
\xbmc[] para apresentar a mensagem no formato \textit{pop-up} representado pela
figura \vref{fig:notification-2}.

\begin{listing}[ht!]
\inputminted{python}{codigos/notification-popup.py}
\caption{Definição do método utilizado para apresentar as notificações no modo
\textit{pop-up}}
\label{lst:notification-popup}
\end{listing}

O método representado no código \ref{lst:notification-ok} faz uso de um outro 
método da API, obtendo o resultado visto na figura \vref{fig:notification-1}.

\begin{listing}[ht!]
\inputminted{python}{codigos/notification-ok.py}
\caption{Definição do método utilizado para apresentar as notificações no modo
ok}
\label{lst:notification-ok}
\end{listing}

A mensagem será exibida na tela de acordo com o tipo de notificação escolhida. 

\subsection{Módulo \textit{service.dado}}\label{subsubsec:dado}

O funcionamento deste módulo baseia-se no acionamento da aplicação através
do controle remoto do \stb[] e a interação através de suas telas no televisor
do usuário. O módulo apresenta uma tela inicial como a apresentada na 
figura \vref{fig:tela-principal-dado}.

O módulo \textit{service.dado} foi desenvolvido utilizando a linguagem
\python[]. O usuário pode iniciar a aplicação através do menu ``Sua Saúde''
(figura \vref{fig:tela-principal}) e em seguida escolher a opção ``Não está se
sentindo bem?'' (figura \vref{fig:tela-principal-sua-saude}) no \stb[] através
do controle remoto. A tela inicial do módulo é  apresentada na figura
\vref{fig:tela-principal-dado}.

O funcionamento deste módulo baseia-se no acionamento da aplicação através
do controle remoto do \stb[] e a interação através de suas telas no televisor
do usuário. O diagrama de sequência apresentado na figura \ref{fig:dado-sd} norteou
o desenvolvimento deste módulo. Percebe-se que o usuário deve inicialmente,
informar os sintomas e também fechar a mensagem com o resultado.

\figurasimples{dado-sd}{Diagrama de Sequência para
módulo \textit{service.dado}.}{10cm}

A partir da tela principal da aplicação, o usuário que se sente mal escolhe 
dentre um conjunto de sintomas, aqueles que representam o seu estado atual. Em
seguida, esses sintomas são enviados através de um \webservice[] para um
módulo de inferência. A conclusão é retornada para o STB, que a processa e 
apresenta para o usuário.

\begin{listing}[ht!]
\inputminted{python}{codigos/dado-main.py}
\caption{Definição de método utilizado para capturar dados do controle remoto
e apresentar através de um alerta.}
\label{lst:dado-main}
\end{listing}

O código \ref{lst:dado-main} demonstra a captura dos sintomas através do
controle remoto do usuário, a requisição à um serviço externo e a apresentação
do resultado através de um alerta. Cada elemento da tela tem um \textit{ID},
assim, é possível identificar qual elemento foi escolhido pelo usuário através
do controle remoto.  Os sintomas estão dispostos em um dicionário da linguagem
\python[] em que cada chave é um \textit{ID} e o valor, o nome do sintoma
(variável \texttt{SINTOMS}). Quando o usuário escolhe um sintoma, este sintoma
é adicionado à variável \texttt{selectedSintoms}, em seguida essa variável é
repassada como parâmetro para a requisição. A resposta da requisição é apresentada
através de um alerta do tipo caixa de diálogo.

\subsection{Módulo \textit{service.panicbutton}}\label{subsubsec:panicbutton}

O módulo \textit{service.panicbutton} tem como objetivo permitir que o usuário
utilize o controle remoto para reportar um momento que precisa de ajuda 
emergencial. Ao acionar a tecla reservada para tal função, o sistema percebe e
prepara um conjunto de tarefas a serem executadas. Dentre elas, o envio de 
mensagens via (1) Serviço de Mensagem Simples (SMS) e (2) serviços de comunicação
pela Internet (como por exemplo o aplicativo \textit{Telegram}) para parentes, 
amigos, cuidador e a equipe médica que o acompanha. Além de entrar em contato
com o serviço de urgência e emergência. O diagrama UML de sequência é apresentado
na figura \ref{fig:panicbutton-sd}.

\figurasimples{panicbutton-sd}{Diagrama de Sequência para
módulo \textit{service.panicbutton}.}{10cm}

Em seguida, o aplicativo exibe uma notificação na tela da televisão no intuito
de acalmá-lo. A figura \ref{fig:notificacao-botao-de-panico} exibe a mensagem 
tranquilizando o usuário.

O módulo foi desenvolvido utilizando a linguagem \python[] e acessando serviços
externos para o envio das mensagens. O código \ref{lst:panicbutton-main} exibe
o método que é executado quando o usuário executa o botão de pânico no controle
remoto. Os contatos cadastrados são requisitados no módulo \web, em seguida, as
mensagens são enviadas, por fim, um aviso é apresentado para o usuário na tela
do televisor.

\begin{listing}[ht!]
\inputminted{python}{codigos/panicbutton-main.py}
\caption{Definição de método utilizado para capturar situação de emergência enviada
pelo usuário.}
\label{lst:panicbutton-main}
\end{listing}

\section{Conectando novos sensores} \label{sec:conectando-novos-sensores}

A API permite que desenvolvedores de dispositivos com sensores passem a fazer
parte da solução. A partir desta abordagem, qualquer um pode contribuir  com
mais dados para o ambiente de assistência domiciliar à saúde. Espera-se que o
dispositivo, seja ele um \textit{hardware} ou um \textit{script}, consiga
realizar requisições HTTP e enviar mensagens MQTT com conteúdo JSON.

A \textit{API Restful} projetada permite que o dispositivo seja encontrado e
adicionado à rede (API de Gerenciamento) e que passe a fazer parte dos sensores
que contribuem com dados para o sistema através da API de Dados.

\tabela{sensors-api}{Métodos disponíveis na API de gerenciamento}{0.9}

Em primeiro momento, o dispositivo precisará realizar requisições HTTP do tipo
\texttt{POST} e \texttt{DELETE}. Uma vez conectado a rede local o dispositivo envia sua
identificação e o \textit{hub} trata essa informação, adicionando o dispositivo
sensor ao sistema, contendo informações como: ID, localização (cômodo da casa
ou corporal), tempo de leitura e unidade de sensoriamento (temperatura, ruído,
nível de oxigênio no sangue etc). Uma vez conectado ao sistema e o dispositivo
tenha sido identificado, ele pode enviar os dados coletados por meio de
mensagens MQTT. 

A API de gerenciamento conta inicialmente com dois métodos, listados na tabela
\ref{tab:sensors-api}. A mensagem JSON que deve ser enviada ao fazer uma
requisição POST no caminho \texttt{api/v1/device/} é apresentada no código
\ref{lst:message-post}.

\begin{listing}[ht!]
\inputminted{json}{codigos/message-post.json}
\caption{Mensagem JSON enviada no corpo da requisição HTTP.}
\label{lst:message-post}
\end{listing}

No passo 1 da figura \ref{fig:sensor-hub} o sensor faz uma requisição HTTP
identificando-se, em seguida o \textit{hub} cadastra o sensor no banco de dados
local e responde com um \textit{ack} (passo 2). O sensor pode agora enviar
dados através do protocolo MQTT, o MQTT \textit{Broker} no \textit{hub} recebe
o dado e em seguida persiste em banco de dados ou repassa o dado para outro
sistema na arquitetura, como por exemplo, a plataforma \nextsaude.

\figurasimples{sensor-hub}{Processo de cadastro de novo sensor.}{8cm}

A API de dados é representada por tópicos do MQTT Broker, que tem como padrão
o caminho \texttt{health/<location>/<sensorID>/<value>/}. Em que os termos 
\texttt{location} e \texttt{sensorID} foram cadastrados através da API de
gerenciamento e o termo \texttt{value} representa o valor da leitura do sensor.
